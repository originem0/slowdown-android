# SlowDown 应用功能说明书

## 概述

**SlowDown** 是一款注重隐私的数字正念Android应用，通过在用户尝试访问分散注意力的应用时引入有意的阻力，帮助用户养成更健康的智能手机使用习惯。该应用将无意识的应用使用转化为有意识的选择，最终减少社交媒体依赖并改善用户专注力和幸福感。

## 核心理念

- **正念使用**：通过干预机制让用户意识到自己的使用行为
- **习惯重塑**：用有益的活动替代无意识的应用浏览
- **隐私保护**：所有数据本地存储，无云端同步
- **温和引导**：提供选择而非强制，尊重用户自主权

---

## 用户操作手册

### 1. 应用安装与初始设置

#### 1.1 首次启动
1. **启动应用**：点击手机桌面上的"SlowDown"图标
2. **授权引导**：系统会引导您完成必要权限的授权
3. **权限说明**：
   - **无障碍服务**：监控应用启动，核心功能
   - **悬浮窗权限**：显示干预界面
   - **使用统计权限**：跟踪使用数据
   - **存储权限**：保存配置和统计数据
   - **通知权限**：发送提醒信息

#### 1.2 权限设置步骤
1. 打开**设置** → **辅助功能** → **SlowDown**
2. 启用无障碍服务
3. 返回应用，系统会自动检测权限状态
4. 根据提示完成其他权限授权

### 2. 主界面操作

#### 2.1 仪表板概览
主界面采用卡片式设计，清晰显示：
- **当前连胜天数**：正中央大字显示连续使用天数
- **今日统计**：显示今天的干预次数和节省时间
- **本周统计**：一周内的使用改善情况
- **本月统计**：月度进度跟踪
- **最近成就**：横向滚动显示解锁的成就

#### 2.2 快捷操作
- **快速暂停按钮**（右下角橙色悬浮按钮）：临时禁用所有干预
- **菜单按钮**（右上角三点图标）：访问各项设置功能

#### 2.3 主菜单选项
- **应用配置**：设置需要干预的应用和干预类型
- **详细统计**：查看更详细的使用数据分析
- **设置**：应用基本设置和偏好配置
- **隐私设置**：数据管理和导出功能
- **权限管理**：检查和重新授权必要权限

### 3. 应用配置功能

#### 3.1 添加需要干预的应用
1. 进入**应用配置**界面
2. 浏览已安装应用列表
3. 选择想要干预的应用（如微信、微博、抖音等）
4. 为每个应用选择合适的干预类型

#### 3.2 干预类型设置
每个应用可以配置不同的干预方式：

**倒计时延迟（推荐新手）**
- 设置延迟时间（3-30秒）
- 倒计时期间展示替代选项
- 时间结束后允许继续访问

**应用跳转**
- 选择替代应用（如微信读书、冥想应用）
- 引导转向有益活动
- 培养积极使用习惯

**文本匹配挑战**
- 上传Markdown格式文本文件
- 随机显示文本段落
- 要求准确输入匹配才能解锁
- 支持智能匹配（忽略大小写、标点符号）

**图片观看任务**
- 上传有意义的图片（如家人照片、目标图片）
- 设置观看时长（10-60秒）
- 强制观看完成后才能继续

**完全阻止**
- 在特定时间段完全禁止访问
- 可设置每日时间规则
- 提供紧急解除选项

### 4. 干预体验流程

#### 4.1 干预触发
当您尝试打开配置的应用时：
1. 系统立即检测应用启动尝试
2. 暂停目标应用启动
3. 显示全屏干预界面
4. 根据配置类型展示相应挑战

#### 4.2 干预界面交互
**倒计时延迟界面**
- 显示倒计时数字
- 提供"打开微信读书"按钮（绿色）
- 提供"继续访问"按钮（灰色，倒计时结束后激活）
- 底部显示强制退出提示

**文本匹配界面**
- 显示随机选择的文本段落
- 提供输入框供用户输入
- 实时验证输入正确性
- 匹配成功后解锁应用访问

**图片观看界面**
- 全屏显示上传的图片
- 大字体倒计时显示剩余观看时间
- 观看期间"继续"按钮为禁用状态
- 时间结束后激活继续按钮

#### 4.3 用户选择选项
在每次干预中，用户都有多种选择：
- **继续访问原应用**：完成干预要求后访问目标应用
- **跳转到阅读应用**：选择有益替代活动
- **取消操作**：返回主屏幕
- **紧急解除**：长按音量上+音量下键5秒

### 5. 统计与进度跟踪

#### 5.1 数据指标
应用跟踪以下关键指标：
- **干预次数**：成功阻止的无意识使用次数
- **节省时间**：通过干预避免的潜在浪费时间
- **成功重定向**：选择有益替代活动的次数
- **连续天数**：持续使用应用的天数
- **最常干预应用**：识别主要问题应用

#### 5.2 进度可视化
- **趋势图表**：显示使用改善趋势
- **成就系统**：解锁不同里程碑成就
- **每周报告**：总结一周的进步情况
- **对比分析**：展示干预前后的使用差异

### 6. 隐私与安全设置

#### 6.1 数据隐私保护
- **本地存储**：所有数据仅存储在设备本地
- **加密保护**：用户数据通过高强度加密算法保护
- **无云端同步**：不收集、不上传任何用户数据
- **透明展示**：清楚显示收集了哪些数据及用途

#### 6.2 数据管理功能
**导出数据**
- 导出完整使用统计数据
- 导出应用配置设置
- 生成标准格式备份文件

**删除数据**
- 选择性删除特定时期数据
- 完全清除所有历史记录
- 安全擦除确保数据无法恢复

**备份恢复**
- 自动创建定期备份
- 手动创建备份快照
- 从备份文件恢复设置和数据

### 7. 安全机制与紧急处理

#### 7.1 系统安全保护
- **关键功能保护**：自动识别电话、短信等关键系统功能，立即允许访问
- **兼容性检查**：检测系统兼容性，自动降级避免冲突
- **资源优化**：最小化电池和内存占用

#### 7.2 紧急解除机制
当您遇到困难或紧急情况时：
1. **硬件按键组合**：同时长按音量上+音量下键5秒
2. **自动记录**：系统记录紧急解除事件
3. **冷却期**：触发后24小时内暂停干预功能
4. **恢复提醒**：24小时后发送通知提醒重新启用

#### 7.3 故障恢复
- **崩溃保护**：应用崩溃不影响手机基本功能
- **自动重启**：服务异常时自动恢复监控
- **降级模式**：权限不足时提供基础功能

---

## 功能模板详细介绍

### 模板1：倒计时延迟干预

#### 功能描述
最基础的干预类型，通过强制等待时间让用户重新思考使用意图。

#### 手机操作效果
1. **触发**：用户点击受监控应用图标
2. **拦截**：应用启动被暂停，显示黑色全屏界面
3. **倒计时**：大字体显示倒计时数字（如"5、4、3、2、1"）
4. **选择提示**：显示"请等待X秒后继续"文字
5. **按钮状态**：
   - "打开微信读书"按钮立即可用（绿色）
   - "继续访问"按钮初期禁用（灰色）
   - 倒计时结束后"继续访问"按钮激活（蓝色）
6. **结果处理**：
   - 选择阅读：启动微信读书应用
   - 选择继续：启动原目标应用
   - 返回键：返回主屏幕

#### 配置选项
- **延迟时长**：3-30秒可调
- **显示消息**：自定义提醒文字
- **替代应用**：设置推荐的健康应用

#### 适用场景
- 初次使用者建立使用意识
- 轻度依赖应用的温和干预
- 建立"暂停思考"的使用习惯

### 模板2：应用跳转干预

#### 功能描述
将用户使用意图从消遣类应用重定向到有益的替代应用。

#### 手机操作效果
1. **触发**：检测到目标应用启动
2. **跳转界面**：显示替代应用选择页面
3. **应用列表**：展示用户预设的有益应用：
   - 微信读书（主推荐）
   - 冥想应用
   - 学习应用
   - 健身应用
   - 其他自定义应用
4. **一键启动**：点击任一应用图标直接启动
5. **原应用选项**：底部提供"仍要打开原应用"选项
6. **统计记录**：记录用户选择，用于后续个性化推荐

#### 配置选项
- **替代应用列表**：从已安装应用中选择
- **优先级排序**：设置推荐应用的显示顺序
- **自动检测**：识别用户常用的有益应用

#### 适用场景
- 培养积极的手机使用习惯
- 用好习惯替代坏习惯
- 建立正向使用模式

### 模板3：文本匹配挑战

#### 功能描述
通过要求用户准确输入指定文本来创建使用摩擦，增强使用意识。

#### 手机操作效果
1. **文件导入**：用户上传Markdown格式文本文件
2. **触发干预**：显示文本匹配挑战界面
3. **文本显示**：
   - 从文件中随机选择一段文字
   - 以大字体清晰显示（通常2-3行）
   - 避免过长或过短的文本段落
4. **输入界面**：
   - 显示输入框和虚拟键盘
   - 实时显示输入内容
   - 智能匹配算法验证正确性
5. **匹配反馈**：
   - 输入正确：绿色对勾，解锁应用
   - 输入错误：红色提示，需要重新输入
   - 部分匹配：黄色提示，显示相似度
6. **智能容错**：
   - 忽略大小写差异
   - 忽略标点符号差异
   - 忽略多余空格
   - 支持中文输入法容错

#### 配置选项
- **文本源**：支持导入多个Markdown文件
- **匹配阈值**：设置匹配严格程度（75%-95%）
- **文本长度**：限制显示文本的字符数范围
- **权重设置**：为不同文本设置出现频率

#### 适用场景
- 增强使用摩擦，适合意志力较强的用户
- 结合学习材料，寓教于乐
- 适合处理严重依赖的应用

### 模板4：图片观看任务

#### 功能描述
要求用户观看有意义的图片指定时长，通过视觉提醒重新连接内在价值。

#### 手机操作效果
1. **图片上传**：用户从相册选择有意义的图片
2. **干预触发**：显示全屏图片观看界面
3. **图片展示**：
   - 图片以最佳比例全屏显示
   - 保持图片清晰度和比例
   - 支持横屏和竖屏自适应
4. **计时器显示**：
   - 大字体倒计时（如"10、9、8..."）
   - 位置在图片下方，不遮挡主要内容
   - 使用对比鲜明的颜色确保可见性
5. **交互限制**：
   - 观看期间"继续"按钮禁用（灰色）
   - 无法通过触摸跳过观看
   - 防止意外触摸中断观看
6. **完成解锁**：
   - 倒计时结束后按钮变为可用（绿色）
   - 显示"观看完成，可以继续"提示
   - 记录观看完成事件

#### 配置选项
- **观看时长**：10-60秒可调
- **图片管理**：支持多张图片轮换
- **显示模式**：全屏、适应屏幕、居中显示
- **图片分类**：家人、目标、名言等分类管理

#### 适用场景
- 情感连接类干预，提醒用户重要的人和事
- 目标激励，显示理想和目标图片
- 正念练习，观看自然风景等平静图片

### 模板5：完全阻止模式

#### 功能描述
在特定时间段完全禁止访问指定应用，提供最强力的使用控制。

#### 手机操作效果
1. **时间规则配置**：设置阻止的时间段和星期
2. **阻止触发**：
   - 在阻止时间内尝试启动应用
   - 显示黑底白字的阻止界面
   - 明确提示"此应用在当前时间段被完全阻止"
3. **替代建议**：
   - 显示有益替代活动列表
   - 提供"打开阅读应用"快捷按钮
   - 显示"进行冥想练习"等建议
4. **紧急解除**：
   - 提供"紧急解除阻止"红色按钮
   - 点击后显示额外确认界面
   - 要求输入解除理由或完成额外挑战
5. **解除后果**：
   - 记录紧急解除事件
   - 显示使用提醒
   - 询问是否调整阻止规则

#### 配置选项
- **时间规则**：精确到小时和分钟
- **星期设置**：选择阻止的星期几
- **紧急解除**：设置解除的额外要求
- **替代推荐**：自定义替代活动建议

#### 适用场景
- 专注工作或学习时段
- 睡前时间管理
- 严重依赖应用的强制干预

---

## 手机操作达到的具体效果

### 1. 即时干预效果

#### 1.1 应用启动拦截
- **响应时间**：< 200毫秒内检测并拦截应用启动
- **视觉效果**：目标应用图标点击后不会正常启动，而是显示干预界面
- **用户感知**：明显的使用中断，强制用户暂停并思考

#### 1.2 全屏沉浸体验
- **界面特性**：黑色背景，白色文字，简洁设计
- **注意力聚焦**：移除所有干扰元素，专注于干预任务
- **视觉冲击**：与常规应用界面形成强烈对比

#### 1.3 交互限制
- **返回键控制**：防止用户通过返回键绕过干预
- **多任务限制**：在干预完成前无法切换到其他应用
- **强制完成**：必须选择一个选项才能继续

### 2. 行为改变效果

#### 2.1 使用意识提升
- **暂停效应**：强制中断无意识的使用习惯
- **选择意识**：每次使用都需要做出明确选择
- **时间感知**：通过倒计时增强时间成本意识

#### 2.2 习惯重塑机制
- **替代强化**：多次推荐健康替代选项
- **正向反馈**：选择有益活动时给予积极反馈
- **渐进调整**：根据用户行为自动调整干预策略

#### 2.3 长期行为模式改变
- **减少无意识使用**：统计显示无意识启动次数下降
- **增加有意识选择**：用户更多选择继续使用而非被动浏览
- **时间重新分配**：节省的时间用于更有意义的活动

### 3. 数据反馈效果

#### 3.1 实时统计更新
- **即时记录**：每次干预都实时更新统计数据
- **可视化反馈**：主界面卡片实时显示数据变化
- **趋势展示**：图表显示使用改善趋势

#### 3.2 成就系统激励
- **里程碑解锁**：达到特定目标时显示成就通知
- **进度可视化**：连胜天数、节省时间等直观展示
- **社会比较**：与个人历史记录对比激励进步

#### 3.3 个性化建议
- **使用模式分析**：识别用户最容易分心的时间和应用
- **定制化干预**：根据成功率调整干预类型和强度
- **智能提醒**：在容易分心的时间主动提醒用户

### 4. 系统集成效果

#### 4.1 无缝系统集成
- **后台运行**：不影响手机正常功能和其他应用
- **资源优化**：最小化电池和内存占用
- **权限协调**：与Android系统权限系统完美配合

#### 4.2 兼容性保障
- **多设备适配**：支持不同品牌和型号的Android设备
- **系统版本兼容**：从Android 6.0到最新版本
- **第三方应用兼容**：不与其他应用产生冲突

#### 4.3 安全性保障
- **隐私保护**：所有数据本地加密存储
- **系统稳定性**：崩溃保护机制确保手机正常使用
- **紧急访问**：关键功能（电话、短信）始终可用

### 5. 用户体验优化效果

#### 5.1 学习曲线优化
- **引导教程**：首次使用时提供详细操作指导
- **渐进式复杂性**：从简单干预开始，逐步增加挑战
- **个性化设置**：根据用户反馈调整界面和功能

#### 5.2 情感设计
- **温和而坚定**：界面设计传达关怀而非惩罚
- **积极引导**：强调选择和成长而非限制和控制
- **成就感营造**：通过进步跟踪增强用户成就感

#### 5.3 长期可持续性
- **习惯养成支持**：21天、66天等习惯形成周期跟踪
- **动机维持**：通过多样化干预保持新鲜感
- **社区支持**：提供用户交流和相互激励的功能

---

## 技术特性与优势

### 1. 隐私保护技术
- **端到端加密**：用户数据全程加密保护
- **本地处理**：所有数据处理在设备本地完成
- **零数据收集**：不收集任何用户个人信息
- **透明度**：开源代码供用户审查

### 2. 系统优化技术
- **低功耗设计**：智能算法最小化电池消耗
- **内存管理**：高效的内存使用和垃圾回收
- **启动优化**：快速响应应用启动检测
- **崩溃恢复**：自动恢复机制确保服务稳定

### 3. 智能算法
- **文本匹配算法**：基于Levenshtein距离的智能匹配
- **使用模式识别**：机器学习识别用户使用模式
- **自适应调整**：根据成功率自动优化干预策略
- **预测分析**：预测用户可能的分心时间

### 4. 可扩展架构
- **模块化设计**：支持新增干预类型和功能
- **插件系统**：第三方开发者可以开发扩展
- **API接口**：提供数据导出和集成接口
- **国际化支持**：多语言界面和文本处理

---

## 常见问题与解决方案

### Q1: 如何处理紧急情况？
**A**: 长按音量上+音量下键组合5秒即可紧急解除所有干预，确保在紧急情况下能正常使用手机的所有功能。

### Q2: 会影响电话和短信功能吗？
**A**: 不会。应用内置智能识别系统，自动检测电话、短信等关键系统功能，并立即允许访问，绝不干扰重要通讯。

### Q3: 数据会被上传到云端吗？
**A**: 绝对不会。所有用户数据都仅存储在设备本地，采用高强度加密保护，应用不包含任何网络上传功能。

### Q4: 如何备份我的设置和数据？
**A**: 在隐私设置中选择"导出数据"，可以生成包含所有配置和统计数据的备份文件，便于设备迁移或数据恢复。

### Q5: 应用会消耗大量电池吗？
**A**: 不会。应用采用高效的后台监控算法，正常使用情况下电池消耗不到1%，不会明显影响设备续航。

---

## 结语

**SlowDown** 应用致力于帮助用户建立更健康、更有意识的数字生活方式。通过温和而有效的干预机制，让每一次应用使用都成为深思熟虑的选择，最终实现数字设备为我所用，而非被设备控制的理想状态。

我们相信，真正的自由不是无限制地使用，而是有能力选择如何使用。**SlowDown** 为您提供这种选择的能力，让您重新掌控自己的数字生活。

---

*本文档基于应用当前功能编写，如有功能更新，请以应用内实际体验为准。*

---

## 开发日志：第二阶段 Bug 修复记录

### 修复日期：2026-01-17

#### Bug 1：限制模式切换逻辑错误

**问题表现：**
- 选择"仅统计"后无法切换到其他模式
- "完全禁止"和"严格限制"可以互换，但无法切换到"温和提醒"
- 添加应用默认是温和提醒，选择其他选项后无法切回

**根本原因：**
`onModeChange` 处理器进行多次独立的 ViewModel 调用（`updateEnabled`、`updateLimitMode`、`updateDailyLimit`），导致状态竞争条件。当快速连续调用时，后面的更新可能基于旧状态执行。

**解决方案：**
在 `AppDetailViewModel.kt` 中添加原子更新方法：
```kotlin
fun updateRestrictionMode(isEnabled: Boolean, limitMode: String, dailyLimitMinutes: Int?) {
    viewModelScope.launch {
        _monitoredApp.value?.let { app ->
            val updated = app.copy(
                isEnabled = isEnabled,
                limitMode = limitMode,
                dailyLimitMinutes = dailyLimitMinutes
            )
            repository.updateMonitoredApp(updated)
        }
    }
}
```

**关键学习：** 多个相关状态字段必须原子更新，避免中间状态导致的竞争条件。

---

#### Bug 2：英文字母搜索不准确

**问题表现：**
在应用列表页面搜索时，输入英文字母无法正确匹配应用名称。

**根本原因：**
1. 中日文输入法可能产生全角英文字母（如 `ａｂｃ` 而非 `abc`）
2. 大小写转换在不同 Locale 下行为不一致

**解决方案：**
在 `AppListScreen.kt` 中：
1. 使用 `Locale.ROOT` 进行一致的大小写转换
2. 添加 `toHalfWidth()` 函数处理全角转半角：
```kotlin
private fun String.toHalfWidth(): String {
    val sb = StringBuilder()
    for (char in this) {
        val code = char.code
        if (code == 0x3000) {
            sb.append(' ')  // 全角空格
        } else if (code in 0xFF01..0xFF5E) {
            sb.append((code - 0xFEE0).toChar())  // 全角转半角
        } else {
            sb.append(char)
        }
    }
    return sb.toString()
}
```

**关键学习：** CJK 输入法兼容性需要考虑全角/半角字符转换。

---

#### Bug 3：弹窗在离开被监控应用后仍然弹出

**问题表现：**
用户已退出被监控应用，在 SlowDown 主界面或其他应用时，深呼吸弹窗仍然弹出。

**根本原因：**
1. `currentForegroundApp` 在用户切换到 SlowDown 或系统应用时未被清除
2. 定期同步回调检查的是旧的 `currentForegroundApp` 值
3. `OverlayService` 使用 `WindowManager.TYPE_APPLICATION_OVERLAY` 无条件覆盖所有应用

**解决方案：**
在 `AppMonitorService.kt` 中实现三层前台验证防护：

**第1层 - 事件接收时清除追踪：**
```kotlin
// 切换到 SlowDown 自己
if (packageName == this.packageName) {
    currentForegroundApp = null
    return
}
// 切换到系统应用
if (PackageUtils.isSystemCriticalApp(packageName)) {
    currentForegroundApp = null
    return
}
```

**第2层 - 同步回调验证：**
```kotlin
usageTrackingManager.setOnSyncCompleteListener { updatedPackages ->
    val currentFg = currentForegroundApp
    if (currentFg != null && currentFg in updatedPackages) {
        val actualForeground = rootInActiveWindow?.packageName?.toString()
        if (actualForeground == currentFg) {
            checkAndShowUsageWarning(currentFg)
        }
    }
}
```

**第3层 - 启动弹窗前最终验证：**
```kotlin
private fun launchDeepBreathOverlay(...) {
    val actualForeground = rootInActiveWindow?.packageName?.toString()
    if (actualForeground != null && actualForeground != packageName) {
        return  // 不匹配，跳过
    }
    // 继续启动弹窗
}
```

**关键学习：** 悬浮窗/弹窗必须在多个检查点验证前台状态，单一检查点不足以防止误触发。

---

### 相关文档

- 弹窗逻辑详细说明：[popup-logic-flowchart.md](./popup-logic-flowchart.md)

### 修改的文件清单

| 文件 | 修改内容 |
|------|---------|
| `AppDetailViewModel.kt` | 添加 `updateRestrictionMode()` 原子更新方法 |
| `AppDetailScreen.kt` | 修改 `onModeChange` 使用原子更新 |
| `AppListScreen.kt` | 添加 `Locale.ROOT` 和 `toHalfWidth()` |
| `AppMonitorService.kt` | 实现三层前台验证防护机制 |

---

#### Bug 4：应用内持续操作时深呼吸弹窗不触发

**问题表现：**
在被监控应用内持续滑动、点击时，即使 cooldown 时间到期，深呼吸弹窗也不会触发。只有退出到后台再返回时才会触发。

**根本原因：**
`handleRealtimeTracking` 函数在检测到同一应用的事件时直接 return：
```kotlin
// 如果是同一个应用，不需要处理
if (newPackageName == currentForegroundApp) return
```
这导致 cooldown 检查被完全跳过。

**解决方案：**
将使用时间记录和弹窗检查逻辑分离：
1. 使用时间记录：只在切换到不同应用时才记录
2. 弹窗检查：**每次事件都检查**，让 cooldown 机制来控制是否触发

```kotlin
val isSameApp = newPackageName == currentForegroundApp

// 只有切换到不同应用时才记录使用时间和重置追踪
if (!isSameApp) {
    // ... 记录使用时间，更新追踪状态
}

// 检查是否需要触发弹窗（无论是否同一应用都检查）
checkAndShowUsageWarning(newPackageName)
```

**关键学习：** 记录逻辑和触发逻辑应该分离，避免一个条件跳过影响另一个功能。

---

#### 新功能：短视频模式（主动触发）

**功能背景：**
短视频应用（如抖音、B站）使用 ViewPager2/RecyclerView 实现视频切换，竖滑视频时不会产生 `TYPE_WINDOW_STATE_CHANGED` 事件，导致基于被动触发的弹窗机制无法检测到用户持续使用。

**解决方案：**
为短视频应用添加"短视频模式"，使用定时器主动触发弹窗检查。

**实现细节：**
1. 在 `MonitoredApp` 实体中添加 `isVideoApp: Boolean` 字段
2. 在 `AppMonitorService` 中实现定时检查机制：
   - 使用 `Handler` + `Runnable` 实现 30 秒间隔的定时检查
   - 每次检查时验证前台应用是否仍是目标视频应用
   - 通过 cooldown 机制控制弹窗触发频率
3. 定时器启停逻辑：
   - 进入视频应用时启动定时器
   - 离开视频应用（切换到其他应用/桌面/SlowDown）时停止定时器
   - 服务销毁时停止定时器

**用户操作：**
1. 进入应用详情页
2. 在"其他设置"区域找到"短视频模式"开关
3. 开启后，该应用将使用主动触发模式

**适用场景：**
- 抖音、快手等短视频应用
- B站、YouTube 等视频平台
- 任何使用滑动切换内容的应用

**注意事项：**
- 短视频模式会增加少量电量消耗（每 30 秒一次检查）
- 普通应用建议使用默认的被动触发模式
- 定时器触发仍受 cooldown 机制控制，不会产生过于频繁的弹窗

---

#### Bug 5：短视频模式在全屏播放时定时器停止

**问题表现：**
刷短视频时没有弹窗反应，直到点进评论区才触发弹窗。

**根本原因：**
`rootInActiveWindow` 在全屏视频播放（SurfaceView/TextureView）时返回 `null`。原代码将 `null` 视为"用户已离开应用"并停止定时器：
```kotlin
// ❌ 错误：null 时停止定时器
if (actualForeground != targetApp) {
    stopVideoAppCheck()  // null != targetApp，误停止
    return
}
```

**解决方案：**
修改判断逻辑，只有当 `actualForeground` 明确是其他应用时才停止定时器：
```kotlin
// ✅ 正确：区分 null、匹配、不匹配三种情况
if (actualForeground != null && actualForeground != targetApp) {
    stopVideoAppCheck()  // 明确切换到其他应用才停止
    return
}

if (actualForeground == null) {
    Log.d(TAG, "Foreground is null (fullscreen video?), proceeding anyway")
}
// 继续检查...
```

**关键学习：** `rootInActiveWindow` 在全屏视频、WebView 渲染等特殊 UI 状态下会返回 `null`，不能将 `null` 等同于"用户离开"。

---

#### Bug 6：浏览器应用内持续浏览时弹窗不触发

**问题表现：**
在 Chrome 浏览器中持续浏览页面，弹窗不出现，退出再进入才触发。

**根本原因：**
与 Bug 5 同一问题。定期同步回调（`onSyncCompleteListener`）中对 `rootInActiveWindow == null` 的处理与视频定时器相同：
```kotlin
// ❌ 错误：null 时跳过检查
if (actualForeground == currentFg) {
    checkWarning()
} else {
    skip()  // null 也会进入这里
}
```

**解决方案：**
修改 sync callback 逻辑，当 `actualForeground == null` 时也继续检查弹窗：
```kotlin
// ✅ 正确：null 时也继续检查
if (actualForeground == currentFg || actualForeground == null) {
    checkWarning()
} else {
    skip()
}
```

**关键学习：** 同一个 `rootInActiveWindow == null` 问题影响了多个代码路径（视频定时器、sync callback），需要全面排查。

---

### 修改的文件清单（补充）

| 文件 | 修改内容 |
|------|---------|
| `AppDatabase.kt` | 数据库版本 2→3，添加 `MIGRATION_2_3` |
| `AppMonitorService.kt` | 修复 `videoAppCheckRunnable` 和 `onSyncCompleteListener` 中的 null 处理 |
| `popup-logic-flowchart.md` | 添加"十二、rootInActiveWindow 的特殊行为"章节 |