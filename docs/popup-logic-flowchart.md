# SlowDown 弹窗逻辑流程图

## 一、弹窗类型说明

| 弹窗类型 | Activity | 触发条件 | 重复策略 |
|---------|----------|---------|---------|
| 深呼吸弹窗 | OverlayActivity | 无限制+软提醒 / 有限制应用≥80% | 可重复，受 cooldown 控制 |
| 深呼吸弹窗（限额风格） | OverlayActivity | 有限制+软提醒+≥100% | 可重复，受 cooldown 控制 |
| 100%强制关闭 | UsageWarningActivity (STRICT) | 有限制+强制+≥100% / **无限制+强制** | 每次打开都触发 |

> **注意**：80% 和 100% 的软提醒已统一使用深呼吸弹窗（OverlayActivity），100% 时显示不同的 UI 风格（紫色调背景、橙色进度圈、"休息一下"文案）

## 二、触发机制说明

### 2.1 被动触发机制

弹窗触发依赖 **AccessibilityEvent 事件**，而不是定时器。

**只有以下用户操作会触发检查：**
- 打开一个新应用（窗口切换）
- 应用内部页面跳转（Activity 切换）
- 弹出对话框/菜单
- 屏幕滑动导致的 UI 状态变化

**这意味着：**
- 如果用户在应用内静止不操作（如看视频），不会触发新的弹窗检查
- 冷却时间到达后，需要用户产生新的操作才会触发下一次弹窗
- 这是**设计预期行为**，省电且非侵入

### 2.2 前台验证机制（三层防护）

为防止弹窗在错误的时机显示（如用户已离开被监控应用），系统有三层防护：

```
┌─────────────────────────────────────────────────────────────────┐
│                     第1层：事件接收时                            │
│   onAccessibilityEvent 中清除 currentForegroundApp              │
│   - 切换到 SlowDown 自己 → 清除追踪                             │
│   - 切换到系统应用（桌面等） → 清除追踪                          │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                     第2层：检查警告时                            │
│   checkAndShowUsageWarning / handleAppLaunch                    │
│   - 通过 rootInActiveWindow 验证实际前台应用                     │
│   - 如果 SlowDown 在前台 → 跳过                                 │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                     第3层：启动弹窗前                            │
│   launchDeepBreathOverlay / launchUsageWarningActivity          │
│   - 最后验证 rootInActiveWindow == 目标应用                     │
│   - 如果不匹配 → 直接返回，不启动弹窗                            │
└─────────────────────────────────────────────────────────────────┘
```

## 三、弹窗触发流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                    用户打开被监控应用                              │
│              (AccessibilityEvent 触发)                           │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
                    ┌───────────────────────┐
                    │  前台验证：实际前台    │
                    │  是否为目标应用？      │
                    └───────────────────────┘
                         │           │
                        是           否
                         │           │
                         ▼           ▼
              ┌──────────────┐   [跳过，不处理]
              │ 应用是否有   │
              │ 时间限制？   │
              └──────────────┘
                 │        │
                否        是
                 │        │
                 ▼        ▼
    ┌────────────────┐  ┌─────────────────────┐
    │   限制模式？   │  │ 计算使用时间比例     │
    └────────────────┘  │ ratio = 已用/限额    │
          │      │      └─────────────────────┘
        软提醒  强制              │
          │      │    ┌─────────┴─────────┬─────────────┐
          ▼      ▼    ▼                   ▼             ▼
   ┌──────────┐ ┌────────────┐  ratio < 80%  80%≤ratio<100%  ratio ≥ 100%
   │检查      │ │直接显示强制 │      │              │             │
   │cooldown  │ │关闭弹窗    │      ▼              ▼             ▼
   │是否已过？│ │(该应用已被 │  [不触发弹窗]  ┌──────────────┐  ┌───────────┐
   └──────────┘ │限制)       │               │ 检查 cooldown │  │ 限制模式？ │
      │    │    └────────────┘               │ 是否已过？    │  └───────────┘
     否    是                                └──────────────┘      │      │
      │    │                                    │      │         软提醒  强制
      ▼    ▼                                   否      是           │      │
   [跳过] ┌──────────┐                          │      │           ▼      ▼
          │前台验证  │                          ▼      ▼    ┌──────────┐ ┌──────────┐
          │再次确认  │                       [跳过] [显示深呼吸] │检查      │ │显示强制   │
          └──────────┘                                弹窗    │cooldown  │ │关闭弹窗   │
              │                                              │显示深呼吸 │ │          │
              ▼                                              │(限额风格) │ │          │
       [显示深呼吸弹窗]                                       └──────────┘ └──────────┘
```

## 四、动态同步间隔流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                     定期同步任务触发                              │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                   同步完成后的回调处理                            │
│   1. 检查 currentForegroundApp 是否在更新列表中                  │
│   2. 通过 rootInActiveWindow 验证实际前台                        │
│   3. 只有两者一致时才触发 checkAndShowUsageWarning               │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
                    ┌───────────────────────┐
                    │   检查所有监控应用      │
                    └───────────────────────┘
                                │
                ┌───────────────┼───────────────┐
                ▼               ▼               ▼
        ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐
        │ 条件1:      │  │ 条件2:      │  │ 条件3:          │
        │ 任何应用    │  │ 任何应用    │  │ 以上都不满足    │
        │ 限额<10分钟 │  │ 使用≥80%限额│  │                 │
        └─────────────┘  └─────────────┘  └─────────────────┘
                │               │                   │
                ▼               ▼                   ▼
        ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐
        │ 同步间隔    │  │ 同步间隔    │  │ 同步间隔        │
        │ = 1 分钟    │  │ = 1 分钟    │  │ = 5 分钟        │
        └─────────────┘  └─────────────┘  └─────────────────┘
```

## 五、详细逻辑说明

### 5.1 深呼吸弹窗 (OverlayActivity)

**触发条件：**
1. **无时间限制 + 软提醒模式**：每次打开触发（受 cooldown 控制）
2. **有时间限制的应用**：
   - 使用时间 ≥ 80% 时触发（受 cooldown 控制）- 显示普通风格
   - 使用时间 ≥ 100% + 软提醒模式：继续触发深呼吸（受 cooldown 控制）- 显示限额风格

**UI 风格区分：**
- **普通风格**（≥80% 或无限制）：蓝灰色渐变背景、青色进度圈、"深呼吸"+"你正要打开 XXX"
- **限额风格**（≥100%）：紫灰色渐变背景、橙色进度圈、"休息一下"+"XXX 已达到今日限额"+"今日已使用 X 分钟"

**不触发条件：**
- 无时间限制 + 强制关闭模式（直接显示强制关闭弹窗）
- **当前前台不是目标应用**（三层防护验证）

**cooldown 机制：**
- 由用户设置的 `cooldownMinutes` 控制
- 同一应用在 cooldown 时间内不会重复触发深呼吸
- **注意**：cooldown 是"最小间隔"而非"精确间隔"，实际间隔取决于用户何时产生操作

### 5.2 100%强制关闭弹窗 (UsageWarningActivity - STRICT)

**触发条件（满足任一）：**
1. **无时间限制 + 强制关闭模式**：打开应用就触发
   - UI 显示："该应用已被限制"、"已设置为禁止使用"
2. **有时间限制 + 强制关闭模式 + 使用时间 ≥ 100%**：达到限额时触发
   - UI 显示："今日限额已用完"、"今日已使用 X 分钟"

**重复策略：**
- 每次打开都触发，阻止用户继续使用
- 按返回键或点击按钮都会返回桌面

### 5.3 动态同步间隔

**1分钟同步条件（满足任一）：**
1. 任何监控应用的时间限额 < 10 分钟
2. 任何监控应用的使用时间 ≥ 80% 限额

**5分钟同步条件：**
- 不满足上述任何条件时

**注意：** 无限制应用不影响同步间隔（因为不依赖使用时间数据）

## 六、数据结构

```kotlin
// 冷却时间记录（深呼吸弹窗）
cooldownMap: Map<String, Long>  // packageName -> lastTriggerTime

// 当前追踪的前台应用（用于同步回调验证）
currentForegroundApp: String?   // 当前前台应用包名，切换到 SlowDown/系统应用时清空

// 今天已达到100%限额的应用（用于日志记录）
shownLimitWarningToday: Set<String>  // packageNames

// 上次重置日期（用于每天清空记录）
lastResetDate: String  // "2024-01-17"
```

## 七、场景矩阵（完整版）

| 组合 | 时间限制 | 模式 | 行为 |
|------|---------|------|------|
| A | 无限制 | 软提醒 | 深呼吸弹窗（普通风格，受 cooldown 控制） |
| B | 无限制 | **强制关闭** | **直接显示强制关闭弹窗**（每次打开都触发）|
| C | 有限制 | 软提醒 | <80%：无弹窗<br>≥80%<100%：深呼吸（普通风格，受 cooldown）<br>≥100%：深呼吸（限额风格，受 cooldown） |
| D | 有限制 | 强制关闭 | <80%：无弹窗<br>≥80%<100%：深呼吸（普通风格，受 cooldown）<br>≥100%：每次显示强制关闭弹窗 |

## 八、状态转换表

| 当前状态 | 事件 | 新状态 | 触发弹窗 |
|---------|------|-------|---------|
| 无限制+软提醒 | 打开应用 | - | 深呼吸-普通风格（受cooldown） |
| **无限制+强制关闭** | 打开应用 | - | **强制关闭弹窗** |
| 有限制<80% | 打开应用 | - | 无 |
| 有限制≥80%<100% | 打开应用 | - | 深呼吸-普通风格（受cooldown） |
| 有限制≥100%+软提醒 | 打开应用 | - | 深呼吸-限额风格（受cooldown） |
| 有限制≥100%+强制 | 打开应用 | - | 强制关闭弹窗 |
| **任何状态** | **切换到SlowDown/桌面** | currentForegroundApp=null | **无弹窗** |

## 九、设计理念

1. **深呼吸弹窗（普通风格）**：温和的提醒，让用户意识到自己正在打开目标应用
2. **深呼吸弹窗（限额风格）**：明确告知已达限额，用橙色视觉风格提示，但仍给予选择权
3. **强制关闭弹窗**：用于需要严格控制的场景（如戒除某应用或严格时间管理）
4. **完全禁止模式**（无限制+强制关闭）：一打开就阻止，用于完全禁用某应用
5. **被动触发机制**：省电、非侵入，只在用户主动操作时才介入
6. **三层前台验证**：确保弹窗只在正确的时机显示，避免在其他应用中误触发

## 十、常见问题

### Q1: 为什么冷却时间到了弹窗没有立即出现？

**A**: 这是设计预期行为。弹窗采用被动触发机制，依赖 AccessibilityEvent 事件。只有当用户在应用内产生操作（如滑动、点击、页面跳转）时才会触发检查。如果用户只是静静观看内容，不会触发新的弹窗。

### Q2: 为什么离开被监控应用后弹窗还会弹出？

**A**: 这是一个已修复的 bug。现在系统有三层防护确保弹窗只在用户确实在被监控应用中时才会显示。如果仍然出现问题，请检查是否使用了最新版本。

### Q3: cooldown 时间是精确的吗？

**A**: cooldown 是"最小间隔"而非"精确间隔"。例如设置 1 分钟 cooldown：
- 用户 0:00 触发弹窗
- 用户在应用内静止 3 分钟
- 用户 3:00 产生操作 → 此时才触发下一次弹窗
- 实际间隔是 3 分钟，而非 1 分钟

### Q4: 为什么在应用内持续操作时弹窗不触发？

**A**: 这是一个已修复的 bug（2026-01-17）。之前的代码在同一应用内的事件时会直接跳过检查，导致即使 cooldown 到期也不会触发弹窗。修复后，每次事件都会检查 cooldown 是否到期，到期则触发弹窗。

### Q5: 为什么刷短视频时弹窗不触发？

**A**: 短视频应用（抖音、B站等）使用 ViewPager2/RecyclerView 实现视频切换，竖滑视频时不会产生 `TYPE_WINDOW_STATE_CHANGED` 事件。解决方案：开启"短视频模式"，该模式使用定时器（每 30 秒）主动检查并触发弹窗。

## 十一、短视频模式（主动触发）

### 11.1 工作原理

```
┌─────────────────────────────────────────────────────────────────┐
│                     短视频模式定时检查                            │
└─────────────────────────────────────────────────────────────────┘
                                │
                    ┌───────────▼───────────┐
                    │  用户进入视频应用      │
                    │  (isVideoApp = true)  │
                    └───────────┬───────────┘
                                │
                    ┌───────────▼───────────┐
                    │  启动 30秒 定时器      │
                    │  (startVideoAppCheck) │
                    └───────────┬───────────┘
                                │
        ┌───────────────────────┼───────────────────────┐
        │                       │                       │
        ▼                       ▼                       ▼
  ┌──────────┐          ┌──────────────┐        ┌──────────────┐
  │ 30秒到达  │          │ 用户离开应用  │        │ 切换到其他   │
  │          │          │ (系统应用)   │        │ 被监控应用   │
  └────┬─────┘          └──────┬───────┘        └──────┬───────┘
       │                       │                       │
       ▼                       ▼                       ▼
 ┌───────────────┐      ┌──────────────┐       ┌──────────────┐
 │ 验证前台是否  │      │ 停止定时器    │       │ 停止旧定时器  │
 │ 仍是目标应用  │      │              │       │ 如果新应用也是 │
 └───────┬───────┘      └──────────────┘       │ 视频应用则    │
         │                                     │ 启动新定时器  │
    ┌────┴────┐                                └──────────────┘
    │         │
   是        否
    │         │
    ▼         ▼
┌────────┐  ┌────────────┐
│检查     │  │停止定时器   │
│cooldown │  │            │
│并触发   │  │            │
│弹窗检查 │  │            │
└────────┘  └────────────┘
```

### 11.2 触发条件

| 条件 | 行为 |
|------|------|
| 进入 `isVideoApp=true` 的应用 | 启动 30 秒定时器 |
| 定时器触发时前台仍是目标应用 | 执行弹窗检查（受 cooldown 控制） |
| 定时器触发时前台已不是目标应用 | 停止定时器 |
| 切换到系统应用/桌面/SlowDown | 停止定时器 |
| 切换到其他被监控应用 | 停止旧定时器，检查新应用是否需要启动新定时器 |

### 11.3 与被动触发的区别

| 特性 | 被动触发（默认） | 主动触发（短视频模式） |
|------|----------------|---------------------|
| 触发机制 | AccessibilityEvent | 30 秒定时器 |
| 适用场景 | 普通应用 | 短视频应用 |
| 电量消耗 | 最低 | 略高（定时器唤醒） |
| 检测滑动视频 | 无法检测 | 可以检测 |
| 精确度 | 依赖用户操作 | 固定间隔 |

## 十二、rootInActiveWindow 的特殊行为（重要）

### 12.1 问题背景

`rootInActiveWindow` 是 AccessibilityService 获取当前前台应用的标准方法，但在某些情况下会返回 `null`：

| 场景 | rootInActiveWindow 返回值 | 用户实际状态 |
|------|--------------------------|-------------|
| 普通应用正常使用 | 应用包名 | 在该应用中 |
| 全屏视频播放（SurfaceView/TextureView） | **null** | 仍在视频应用中 |
| 浏览器 WebView 渲染 | **null** | 仍在浏览器中 |
| 某些游戏的特殊渲染模式 | **null** | 仍在游戏中 |
| 切换到其他应用 | 其他应用包名 | 已离开原应用 |

### 12.2 错误处理方式（已修复）

**错误做法**：将 `null` 视为"用户已离开应用"
```kotlin
// ❌ 错误：null 时跳过检查
if (actualForeground == targetApp) {
    checkWarning()
} else {
    skip()  // null 也会进入这里，导致误跳过
}
```

**正确做法**：三状态判断
```kotlin
// ✅ 正确：区分 null、匹配、不匹配三种情况
when {
    actualForeground == targetApp -> checkWarning()  // 正常匹配
    actualForeground == null -> checkWarning()       // 特殊 UI 状态，继续检查
    else -> skip()                                   // 确实切换到其他应用
}
```

### 12.3 受影响的代码路径

| 代码位置 | 功能 | 修复状态 |
|---------|------|---------|
| `videoAppCheckRunnable` | 短视频模式定时器 | ✅ 已修复（2026-01-17） |
| `onSyncCompleteListener` | 定期同步回调 | ✅ 已修复（2026-01-17） |
| `launchDeepBreathOverlay` | 弹窗启动前验证 | ✅ 已正确处理（null 时继续） |
| `launchUsageWarningActivity` | 强制关闭弹窗验证 | ✅ 已正确处理（null 时继续） |

### 12.4 日志示例

**问题日志**（修复前）：
```
[VideoAppCheck] Foreground changed (null != com.bilibili.app.in), stopping
[Service] Sync completed but actual foreground (null) != tracked (com.android.chrome), skip warning check
```

**正常日志**（修复后）：
```
[VideoAppCheck] Foreground is null (fullscreen video?), proceeding with check anyway
[Service] Sync completed, foreground is null (fullscreen/webview?), proceeding with check anyway for: com.android.chrome
```

## 十三、未来优化建议

1. **考虑使用时间段限制**：如仅在 22:00-06:00 启用限制
2. **考虑添加每周总量限制**：除了每日限额，增加每周使用上限
3. ~~**主动触发模式（可选）**~~：已实现为"短视频模式"
4. **考虑 UsageStatsManager 作为 fallback**：当 `rootInActiveWindow` 返回 `null` 时，可用 `UsageStatsManager` 二次确认前台应用
